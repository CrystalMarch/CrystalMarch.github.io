<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CrystalZhu的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-14T10:08:39.654Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Crystal Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCD</title>
    <link href="http://yoursite.com/2020/02/14/GCD/"/>
    <id>http://yoursite.com/2020/02/14/GCD/</id>
    <published>2020-02-14T10:08:39.654Z</published>
    <updated>2020-02-14T10:08:39.654Z</updated>
    
    <content type="html"><![CDATA[<p>###多线程相关概念<br>######1. 进程与线程<br> 进程: 进程是程序在计算机上的一次执行活动,打开APP就开启了一个进程,它包含多个线程.<br>线程:独立执行的代码段,一个线程同时间只能执行一个任务,反之多线程并发就可以在同一时间执行多个任务</p><p>  iOS程序中,主线程(又叫做UI线程)主要任务是处理UI事件,显示和刷新UI.(只有主程序有直接修改UI的能力)耗时的操作放在子线程(又叫做后台线程,异步线程)在iOS中开子线程去处理耗时的操作,可以有效提高程序的执行效率,提高资源利用率.但是开启线程会占用一定的内存(主线程的堆栈大小是1今晚零点零零抢美沫,第二个线程开始都是512kb,并且该值不能通过编译器开关或者线程API函数来更改)降低程序的性能,所以不要同时开很多线程.<br>######2.线程相关<br>同步线程:同步线程会阻塞当前线程去执行线程内的任务,执行完之后,才会返回当前线程.<br>异步线程:异步线程不会阻塞当前线程,会开启其他线程去执行线程内的任务,<br>串行队列:线程任务按先后顺序逐个执行(需要等待队列里面前面的任务执行完之后再执行新任务).<br>并行队列:多个任务按照添加顺序一起开始执行(不用等待前面的任务执行完才去执行新的任务).<br>######3.多线程中出现的问题<br>######3.1 critical section (临界代码段)<br>  指的是不能同时被两个线程访问的代码段,比如一个变量被并发进程访问后可能会改变变量的值,造成数据污染(数据共享问题)<br>######3.2 race condition (竟态条件)<br>  当多个线程同时访问共享数据时,会发生争用情况,第一个线程读取改变一个变量的值,第二个线程也读区改变了该变量的值,两个线程同时操作了该变量,此时他们会发生竟争来看哪个线程会最后写入这个变量,最后被写入的值,将会被保留下来.<br>######3.3 deadlock (死锁)<br>  两个(多个)线程都要等待对方完成某个操作才能进行下一步,这时就会发生死锁.<br>######3.4 thread safe (线程安全)<br>  一段线程安全的代码(对象),可以同时被多个线程或者并发的任务调度,不会产生问题,非线程安全的只能按次序被访问.<br>######3.5所有mutable对象都是非线程安全的,所有immutable对象都是线程安全的,使用mutable对象,一定要用同步锁来同步访问(@synchronized).<br>######3.6互斥锁<br>能够防止多线程抢夺造成的数据安全问题,但是需要消耗大量的资源<br>######3.7原子属性(atomic)加锁<br>atomic: 原子属性,为setter方法加锁,将属性以automic的形式来声明,该属性变量就能够支持互斥锁了.<br>nonatomic: 非原子属性,不会为setter方法加锁,声明为该属性的变量,客户端应尽量避免多线程争夺同一个资源<br>######3.8 context switch (上下文切换)<br>当一个进程中有多个线程来回切换时, context switch 用来记录执行状态,这样的进程和一般的多线程进程,诶呦太多的差别,但会产生一些额外的开锁.</p><p>###多线程编程技术的优缺点比较<br>#####1. NSThread(抽象层次: 低)<br>优点: 轻量级,简单易用,可以直接操作线程对象<br>缺点:需要自己管理线程的生命周期,线程同步.线程同步对数据的加锁会有一定的开销.<br>#####2.Cocoa NSOperation (抽象层次: 中)<br>优点: 不用关心线程管理,数据的同步的事情,可以把精力放在要执行的操作上,基于GCD,是对GCD的封装,比GCD更加面向对象.<br>#####3.GCD 全称Grand Center Dispatch (抽象层次: 高)<br>优点:是Apple开发的一个多核编程的解决方法,简单易用,效率高,速度快.基于C语言,更加底层高效,并且不是Cocoa框架的一部分,自动管理线程生命周期(创建线程,调度任务,销毁线程).<br>缺点: 使用GCD的场景,如果很复杂,就有非常大的可能遇到死锁问题.</p><p><font color=#008000>GCD抽象层次高,使用简单,因此苹果也推荐使用GCD</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###多线程相关概念&lt;br&gt;######1. 进程与线程&lt;br&gt; 进程: 进程是程序在计算机上的一次执行活动,打开APP就开启了一个进程,它包含多个线程.&lt;br&gt;线程:独立执行的代码段,一个线程同时间只能执行一个任务,反之多线程并发就可以在同一时间执行多个任务&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
